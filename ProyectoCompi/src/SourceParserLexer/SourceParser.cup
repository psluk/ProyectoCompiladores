/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
package ParserLexer;
import java_cup.runtime.*;

//Symbols table management
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;

action code {:
    HashMap<String, ArrayList<String>> listaTablaSimbolos = new HashMap<String, ArrayList<String>>();
    String currentHash;

    public void imprimirTabla(){
        for (String key: listaTablaSimbolos.keySet()) {
            System.out.println("Tabla de símbolo : " + key);
            System.out.println("Valores : ");
            for (String item : listaTablaSimbolos.get(key)) {
                System.out.println(item);
            }
            System.out.println("");
        }
    }

    public String getTipo(ArrayList<String> tablaSimbolos, String id){
        String tipo = "null";
        for (String token : tablaSimbolos) {
            String[] partesToken = token.split(":");
            if(id.equals(partesToken[0])){
                tipo = partesToken[1];
            }
        }
        System.out.println("tipo: " + tipo);
        return tipo;
    }

:}

parser code {:
    // Connect this parser to a scanner!
    LexerProject lexer;
    
    @SuppressWarnings("deprecation")
    public parser(LexerProject lexer){
        this.lexer = lexer;
        this.symbolFactory = new DefaultSymbolFactory();
    }

:}

/* define how to connect to the scanner! */
init with {: :};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */

/* keywords */
terminal            COLACHO, SANNICOLAS, SINTERKLAAS, PAPANOEL, DEDMOROZ;

/* function keywords */
terminal            BOLSA, CHIMENEA;

/* literals */
terminal int        l_SANNICOLAS;
terminal float      l_SINTERKLAAS;
terminal boolean    l_tCOLACHO;
terminal boolean    l_fCOLACHO;
terminal char       l_PAPANOEL;
terminal String     l_DEDMOROZ;

/* operators */

/* assignment */
terminal            ENTREGA;

/* binary */
terminal            RODOLFO, BRIOSO, DANZARIN, BROMISTA, COMETA, CUPIDO;

/* relational */
terminal            CANALLA, CHISPA, BUFON, ASTUTO, COPODENIEVE, FELICIDAD;

/* unary */
terminal            GRINCH, QUIEN;

/* logical */
terminal            MELCHOR, GASPAR, BALTASAR;

/* expressions */
terminal            ABREREGALO, CIERRAREGALO, ABRECUENTO, CIERRACUENTO, FINREGALO, ABREEMPAQUE, CIERRAEMPAQUE;

/* control */
terminal            ELFO, HADA, DUENDE, ENVUELVE, HACE, REVISA, ENVIA, CORTA;

/* I/O */
terminal            NARRA, ESCUCHA;

/* functions */
terminal            ADORNO;

/* identifiers */
terminal            PERSONA;

/* Non-terminals (symbols used in the grammar). */
non terminal        rutaNavideña, gengibre, rutaNavideñaAux, tSantaClaus, tlSantaClaus, creaRegalo, creaEntregaRegalo,
                    regalo, regaloManual, entregaRegalo, regaloEnvuelto, trineoSanta, paqueteTrineoSanta,
                    entregaTrineoSanta, confites, bolsaNavideña, envoltorios, llamadaNavideña, regaloPrin,
                    regaloAgregado, regaloMultiplicado, regaloCompartido, regaloVolador, confiteAdornado,
                    regaloComprado, regaloConfirmado, confite, regalos, mezcla, regresaFiesta, terminaFiesta,
                    narraCuento, escuchaCuento, galletaControl, chocolate, leche, galletaRegalo, galletaNavidad,
                    galletaChocolate, regaloAbierto, bolsaNavideñaAux, navidad;

/* Start symbol (the symbol the parser will start with). */
start with          navidad;

/* Grammar */
/* _`rutaNavideña` = bloque de código_     */
// _(`rutaNavideñaAux` permite un bloque vacío)_

rutaNavideña ::= ABREREGALO gengibre CIERRAREGALO ;

rutaNavideñaAux ::=  rutaNavideña |
               ABREREGALO CIERRAREGALO ;
               
/* _`tSantaClaus` = tipo de santa = tipos_ */

tSantaClaus ::= 
            COLACHO |
            SANNICOLAS |
            SINTERKLAAS |
            PAPANOEL |
            DEDMOROZ ;
            
/* _`tlSantaClaus` = tipo de literal (b)_ */

tlSantaClaus ::= 
            l_SANNICOLAS |
            l_SINTERKLAAS |
            l_tCOLACHO |
            l_fCOLACHO |
            l_PAPANOEL |
            l_DEDMOROZ ;
            
/* _`creaRegalo` = variables (b), (d)_ */

creaRegalo ::= CHIMENEA tSantaClaus PERSONA ;

/* _`creaEntregaRegalo` = asignar variable (d)_ */

creaEntregaRegalo ::= CHIMENEA tSantaClaus PERSONA ENTREGA regalo ;

entregaRegalo ::= PERSONA ENTREGA regalo ;

// Expresiones sueltas:

regalo ::= regaloManual ;

/* _`trineoSanta` = arreglo estático (c)_ */

trineoSanta ::= CHIMENEA tSantaClaus PERSONA ABREEMPAQUE l_SANNICOLAS CIERRAEMPAQUE ;

/* _`paqueteTrineoSanta` = lee un elemento del arreglo_ */

paqueteTrineoSanta ::= PERSONA ABREEMPAQUE l_SANNICOLAS CIERRAEMPAQUE ;

/* _`entregaTrineoSanta`: `AAA[0] <= 1 |` → asignar valor al arreglo estático_ */

entregaTrineoSanta ::= paqueteTrineoSanta ENTREGA tlSantaClaus ;

/* _(a) funciones  -> function int persona (parametros){bloque de código}_ */

confites ::= confites ADORNO tSantaClaus PERSONA |
             tSantaClaus PERSONA ;

bolsaNavideña ::= BOLSA tSantaClaus PERSONA ABRECUENTO confites CIERRACUENTO rutaNavideña |
                  BOLSA tSantaClaus PERSONA ABRECUENTO CIERRACUENTO rutaNavideña ;

envoltorios ::= envoltorios ADORNO PERSONA | PERSONA ;

llamadaNavideña ::= PERSONA ABRECUENTO envoltorios CIERRACUENTO |
                    PERSONA ABRECUENTO CIERRACUENTO ;
                    
/* _(e, f, g) expresiones y combinación de ellas, respetando precedencia_
    - _Se crean cuatro niveles, tal que no se pueda volver de una operación de mayor precedencia a una de menor precedencia: 1: `**`, 2: `~`, 3: `*` o `/`, 4: `+` o `-`_  */

// Se unificarán las expresiones aritméticas, relacionales y lógicas, con la siguiente precedencia:
// - `!` (negación)
// - `++`, `--`, `-` (el `-` unario)
// - `**`
// - `*`, `/`
// - `~`
// - `+`, `-`
// - `<`, `<==`, `>`, `>=`, `==`, `!=`
// - `^` (`AND`)
// - `#` (`OR`)
//
// Por lo tanto, `++3 - 2 <== !2 ^ true` equivaldría a `(((++3) - 2) <== (!2)) ^ true`.

regaloPrin ::= regaloAgregado ;

regaloAgregado ::= regaloAgregado RODOLFO regaloMultiplicado |
                   regaloAgregado BRIOSO regaloMultiplicado  |
                   regaloMultiplicado ;

regaloMultiplicado ::= regaloMultiplicado BROMISTA regaloCompartido |
                       regaloMultiplicado COMETA regaloCompartido |
                       regaloCompartido ;

regaloCompartido ::= regaloCompartido CUPIDO regaloVolador |
                     regaloVolador ;

regaloVolador ::= regaloVolador DANZARIN regaloEnvuelto |
                  regaloEnvuelto ;
                  
/* _(h) Operaciones unarias_ */

confiteAdornado ::= GRINCH PERSONA |
                    QUIEN PERSONA ;
                    
/* _(i) Expresiones relacionales (sobre enteros y flotantes)_ */

regaloComprado ::= regaloComprado CANALLA regaloPrin |
                   regaloComprado CHISPA regaloPrin |
                   regaloComprado BUFON regaloPrin |
                   regaloComprado ASTUTO regaloPrin |
                   regaloComprado COPODENIEVE regaloPrin |
                   regaloComprado FELICIDAD regaloPrin |
                   regaloPrin ;
                   
/* _(j) Expresiones lógicas_ */

// Se necesita una regla adicional (`regaloEnvuelto`) para establecer la prioridad: primero la negación, luego el `AND` y luego el `OR`.

regaloManual ::= regaloManual GASPAR regaloConfirmado |
                 regaloConfirmado ;

regaloConfirmado ::= regaloConfirmado MELCHOR regaloComprado |
                    regaloComprado ;

regaloEnvuelto ::= BALTASAR confite |
                   confite ;

confite ::= ABRECUENTO regalo CIERRACUENTO |
            PERSONA |
            confiteAdornado |
            tlSantaClaus |
            paqueteTrineoSanta |
            llamadaNavideña ;
            
// `gengibre` son las líneas de código

gengibre ::= gengibre regalos |
             regalos ;
             
// `regalos` es una sola línea de código (o un bloque `{...}` con `rutaNavideñaAux`)

regalos ::= creaRegalo FINREGALO | creaEntregaRegalo FINREGALO | entregaRegalo FINREGALO | mezcla |
            regalo FINREGALO | regresaFiesta | terminaFiesta | narraCuento | escuchaCuento | rutaNavideñaAux |
            trineoSanta FINREGALO | entregaTrineoSanta FINREGALO | FINREGALO ;
            
/* _(m) Estructuras de control (`if`-[`elif`]-[`else`]) -> `if(a > b){print(a)|}`_ */

// - `galletaControl` son los `if`, `elif` y `else`
// - `galletaRegalo` = `if`, `galletaNavidad` = `elif` y `galletaChocolate` = `else`
// - `if` es obligatorio; `elif` y `else` son opcionales, así que se incluyen las combinaciones

mezcla ::= galletaControl |
           chocolate |
           leche ;

galletaControl ::= galletaRegalo galletaNavidad galletaChocolate |
                   galletaRegalo galletaNavidad |
                   galletaRegalo galletaChocolate |
                   galletaRegalo ;

galletaRegalo ::= ELFO ABRECUENTO regalo CIERRACUENTO rutaNavideñaAux ;

galletaNavidad ::= HADA ABRECUENTO regalo CIERRACUENTO rutaNavideñaAux ;

galletaChocolate ::= DUENDE rutaNavideñaAux ;

/* _(m) `do-until` y `for`. `return`, `break`_ */

// `chocolate` es el `for` 

chocolate ::= ENVUELVE ABRECUENTO regaloAbierto FINREGALO regalo FINREGALO regaloAbierto CIERRACUENTO rutaNavideñaAux ;

regaloAbierto ::= creaRegalo | creaEntregaRegalo | entregaRegalo | mezcla | regalo | narraCuento | escuchaCuento |
                  rutaNavideñaAux | trineoSanta | entregaTrineoSanta ;
                  
// `regresaFiesta` es `return`

regresaFiesta ::= ENVIA FINREGALO |
                  ENVIA ADORNO regalos FINREGALO ;
                  
// `terminaFiesta` es `break`

terminaFiesta ::= CORTA FINREGALO ;

// leche es el `do until` (se asumió como `do while`):  
// `do {i * 2} until (i < 10)|`

leche ::= HACE rutaNavideñaAux REVISA ABRECUENTO regalo CIERRACUENTO ;

/* _(n) Entrada y salida: `print` y `read` -> `print("hola")` o `print("adios")`_ */

narraCuento ::= NARRA ABRECUENTO l_DEDMOROZ CIERRACUENTO FINREGALO |
                NARRA ABRECUENTO l_PAPANOEL CIERRACUENTO FINREGALO |
                NARRA ABRECUENTO l_SANNICOLAS CIERRACUENTO FINREGALO |
                NARRA ABRECUENTO l_SINTERKLAAS CIERRACUENTO FINREGALO |
                NARRA ABRECUENTO PERSONA CIERRACUENTO FINREGALO ;

escuchaCuento ::= ESCUCHA ABRECUENTO l_SANNICOLAS CIERRACUENTO FINREGALO |
                  ESCUCHA ABRECUENTO l_SINTERKLAAS CIERRACUENTO FINREGALO ;
                  
/* _Producción inicial_ */

bolsaNavideñaAux ::= bolsaNavideñaAux bolsaNavideña |
                     bolsaNavideña ;

navidad ::= {:System.out.println("Inicio de parseo");:} bolsaNavideñaAux {:System.out.println("Fin de parseo");:};